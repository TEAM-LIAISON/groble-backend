name: CD - Deploy to Production

on:
#  repository_dispatch:
#    types: [deploy-production]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      confirm:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        type: string

permissions:
  contents: read

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: groble
  CODEDEPLOY_APPLICATION: groble-app
  CODEDEPLOY_DEPLOYMENT_GROUP: groble-prod-deployment-group
  ECS_CLUSTER: groble-cluster
  ECS_SERVICE: groble-prod-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production  # ÏàòÎèô ÏäπÏù∏ ÌïÑÏöî

    # ÏàòÎèô Ïã§Ìñâ Ïãú ÌôïÏù∏ Îã®Í≥Ñ
    if: |
      (github.event_name == 'repository_dispatch') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'DEPLOY')

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Set deployment info
        id: deploy-info
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "image-tag=${{ github.event.client_payload.image_tag }}" >> $GITHUB_OUTPUT
            echo "image-uri=${{ github.event.client_payload.image_uri }}" >> $GITHUB_OUTPUT
            echo "commit-sha=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
            echo "actor=${{ github.event.client_payload.actor }}" >> $GITHUB_OUTPUT
            echo "run-id=${{ github.event.client_payload.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "image-tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "image-uri=${{ secrets.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "commit-sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "actor=${{ github.actor }}" >> $GITHUB_OUTPUT
            echo "run-id=${{ github.run_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Download deployment artifacts
        if: github.event_name == 'repository_dispatch'
        uses: actions/download-artifact@v4
        with:
          name: deployment-artifacts
          run-id: ${{ steps.deploy-info.outputs.run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

#      - name: Verify image exists in ECR
#        run: |
#          IMAGE_TAG="${{ steps.deploy-info.outputs.image-tag }}"
#          echo "üîç Verifying image exists: $ECR_REPOSITORY:$IMAGE_TAG"
#
#          aws ecr describe-images \
#            --repository-name $ECR_REPOSITORY \
#            --image-ids imageTag=$IMAGE_TAG
#
#          echo "‚úÖ Image verified in ECR"
#
#      - name: Prepare ECS task definition
#        run: |
#          IMAGE_URI="${{ steps.deploy-info.outputs.image-uri }}"
#          echo "üìã Preparing task definition with image: $IMAGE_URI"
#
#          # ÌòÑÏû¨ ÌÉúÏä§ÌÅ¨ Ï†ïÏùò Í∞ÄÏ†∏Ïò§Í∏∞
#          aws ecs describe-task-definition \
#            --task-definition groble-prod-task \
#            --query taskDefinition > task-definition.json
#
#          # ÏÉà Ïù¥ÎØ∏ÏßÄ URIÎ°ú ÏóÖÎç∞Ïù¥Ìä∏
#          jq --arg IMAGE_URI "$IMAGE_URI" \
#             '.containerDefinitions[0].image = $IMAGE_URI' \
#             task-definition.json > updated-task-definition.json
#
#          # Î∂àÌïÑÏöîÌïú ÌïÑÎìú Ï†úÍ±∞
#          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
#             updated-task-definition.json > final-task-definition.json
#
#          echo "‚úÖ Task definition prepared"
#
#      - name: Deploy with CodeDeploy
#        id: deploy
#        run: |
#          echo "üöÄ Starting CodeDeploy deployment..."
#
#          # CodeDeployÏö© Î∞∞Ìè¨ Ìå®ÌÇ§ÏßÄ ÏÉùÏÑ±
#          DEPLOYMENT_ARCHIVE="groble-prod-$(date +%Y%m%d-%H%M%S).zip"
#          zip -r $DEPLOYMENT_ARCHIVE appspec.yml scripts/ final-task-definition.json
#
#          # S3 Î≤ÑÌÇ∑ Ïù¥Î¶Ñ Í∞ÄÏ†∏Ïò§Í∏∞
#          S3_BUCKET=$(aws s3api list-buckets \
#            --query 'Buckets[?contains(Name, `groble-codedeploy-artifacts`)].Name' \
#            --output text | head -1)
#
#          if [ -z "$S3_BUCKET" ]; then
#            echo "‚ùå CodeDeploy S3 bucket not found!"
#            exit 1
#          fi
#
#          # S3Ïóê Î∞∞Ìè¨ ÏïÑÌã∞Ìå©Ìä∏ ÏóÖÎ°úÎìú
#          aws s3 cp $DEPLOYMENT_ARCHIVE s3://$S3_BUCKET/
#
#          echo "üì¶ Deployment package uploaded: $DEPLOYMENT_ARCHIVE"
#
#          # CodeDeploy Î∞∞Ìè¨ ÏãúÏûë
#          DEPLOYMENT_ID=$(aws deploy create-deployment \
#            --application-name $CODEDEPLOY_APPLICATION \
#            --deployment-group-name $CODEDEPLOY_DEPLOYMENT_GROUP \
#            --s3-location bucket=$S3_BUCKET,key=$DEPLOYMENT_ARCHIVE,bundleType=zip \
#            --description "Production deployment - ${{ steps.deploy-info.outputs.image-tag }}" \
#            --query deploymentId \
#            --output text)
#
#          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
#          echo "üéØ CodeDeploy deployment started: $DEPLOYMENT_ID"
#
#      - name: Wait for deployment completion
#        run: |
#          DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment-id }}"
#          echo "‚è≥ Waiting for deployment $DEPLOYMENT_ID to complete..."
#
#          # CodeDeploy Î∞∞Ìè¨ ÏôÑÎ£å ÎåÄÍ∏∞ (ÏµúÎåÄ 30Î∂Ñ)
#          aws deploy wait deployment-successful \
#            --deployment-id $DEPLOYMENT_ID \
#            --cli-read-timeout 1800 \
#            --cli-connect-timeout 60
#
#          # Î∞∞Ìè¨ ÏÉÅÌÉú ÌôïÏù∏
#          DEPLOYMENT_STATUS=$(aws deploy get-deployment \
#            --deployment-id $DEPLOYMENT_ID \
#            --query 'deploymentInfo.status' \
#            --output text)
#
#          echo "‚úÖ Deployment completed with status: $DEPLOYMENT_STATUS"
#
#      - name: Verify deployment
#        run: |
#          echo "üîç Verifying deployment..."
#
#          # ECS ÏÑúÎπÑÏä§ ÏÉÅÌÉú ÌôïÏù∏
#          SERVICE_INFO=$(aws ecs describe-services \
#            --cluster $ECS_CLUSTER \
#            --services $ECS_SERVICE \
#            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}')
#
#          echo "üìä ECS Service Status: $SERVICE_INFO"
#
#          # Î°úÎìúÎ∞∏Îü∞ÏÑú Ìó¨Ïä§Ï≤¥ÌÅ¨ ÌôïÏù∏
#          LB_DNS=$(aws elbv2 describe-load-balancers \
#            --names groble-load-balancer \
#            --query 'LoadBalancers[0].DNSName' \
#            --output text)
#
#          echo "üîç Testing application health..."
#
#          # Ìó¨Ïä§Ï≤¥ÌÅ¨ (ÏµúÎåÄ 5Î∂Ñ ÎåÄÍ∏∞)
#          for i in {1..10}; do
#            if curl -f -s "https://$LB_DNS/health" > /dev/null; then
#              echo "‚úÖ Application is healthy!"
#              break
#            elif [ $i -eq 10 ]; then
#              echo "‚ùå Application health check failed after 5 minutes"
#              exit 1
#            else
#              echo "‚è≥ Waiting for application to be ready... ($i/10)"
#              sleep 30
#            fi
#          done
#
#      - name: Notify deployment status
#        if: always()
#        uses: 8398a7/action-slack@v3
#        with:
#          status: ${{ job.status }}
#          text: |
#            üöÄ Production Deployment ${{ job.status }}!
#            Image: ${{ steps.deploy-info.outputs.image-tag }}
#            Commit: ${{ steps.deploy-info.outputs.commit-sha }}
#            Actor: ${{ steps.deploy-info.outputs.actor }}
#            Deployment ID: ${{ steps.deploy.outputs.deployment-id }}
#        env:
#          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}