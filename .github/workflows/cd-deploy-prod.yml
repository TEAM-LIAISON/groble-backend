name: CD - Deploy to Production

on:
  repository_dispatch:
    types: [deploy-production]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
      confirm:
        description: 'Type "DEPLOY" to confirm production deployment'
        required: true
        type: string

permissions:
  contents: read

env:
  AWS_REGION: ap-northeast-2
  ECR_REPOSITORY: groble-prod-spring-api
  CODEDEPLOY_APPLICATION: groble-app
  CODEDEPLOY_DEPLOYMENT_GROUP: groble-prod-deployment-group
  ECS_CLUSTER: groble-cluster
  ECS_SERVICE: groble-prod-service

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production  # ìˆ˜ë™ ìŠ¹ì¸ í•„ìš”

    # ìˆ˜ë™ ì‹¤í–‰ ì‹œ í™•ì¸ ë‹¨ê³„
    if: |
      (github.event_name == 'repository_dispatch') ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.confirm == 'DEPLOY')

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Set deployment info
        id: deploy-info
        run: |
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "image-tag=${{ github.event.client_payload.image_tag }}" >> $GITHUB_OUTPUT
            echo "image-uri=${{ github.event.client_payload.image_uri }}" >> $GITHUB_OUTPUT
            echo "commit-sha=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
            echo "actor=${{ github.event.client_payload.actor }}" >> $GITHUB_OUTPUT
            echo "run-id=${{ github.event.client_payload.run_id }}" >> $GITHUB_OUTPUT
            echo "environment=${{ github.event.client_payload.environment }}" >> $GITHUB_OUTPUT
            echo "branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
            echo "workflow-run-id=${{ github.event.client_payload.workflow_run_id }}" >> $GITHUB_OUTPUT
          else
            echo "image-tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "image-uri=${{ secrets.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "commit-sha=${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "actor=${{ github.actor }}" >> $GITHUB_OUTPUT
            echo "run-id=${{ github.run_id }}" >> $GITHUB_OUTPUT
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
            echo "workflow-run-id=${{ github.run_id }}" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify image exists in ECR
        run: |
          IMAGE_TAG="${{ steps.deploy-info.outputs.image-tag }}"
          echo "ğŸ” Verifying image exists: $ECR_REPOSITORY:$IMAGE_TAG"

          aws ecr describe-images \
            --repository-name $ECR_REPOSITORY \
            --image-ids imageTag=$IMAGE_TAG

          echo "âœ… Image verified in ECR"

      - name: Register new ECS task definition
        id: task-def
        run: |
          IMAGE_URI="${{ steps.deploy-info.outputs.image-uri }}"
          echo "ğŸ“‹ Registering new task definition with image: $IMAGE_URI"

          # í˜„ì¬ íƒœìŠ¤í¬ ì •ì˜ ê°€ì ¸ì˜¤ê¸°
          aws ecs describe-task-definition \
            --task-definition groble-prod-task \
            --query taskDefinition > task-definition.json

          # ìƒˆ ì´ë¯¸ì§€ URIë¡œ ì—…ë°ì´íŠ¸
          jq --arg IMAGE_URI "$IMAGE_URI" \
             '.containerDefinitions[0].image = $IMAGE_URI' \
             task-definition.json > updated-task-definition.json

          # ë¶ˆí•„ìš”í•œ í•„ë“œ ì œê±°
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)' \
             updated-task-definition.json > clean-task-definition.json

          # ìƒˆ Task Definition ë“±ë¡
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://clean-task-definition.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "task-definition-arn=$TASK_DEF_ARN" >> $GITHUB_OUTPUT
          echo "âœ… Task definition registered: $TASK_DEF_ARN"

      - name: Prepare AppSpec with Task Definition ARN
        run: |
          TASK_DEF_ARN="${{ steps.task-def.outputs.task-definition-arn }}"
          echo "ğŸ“‹ Preparing AppSpec with Task Definition ARN: $TASK_DEF_ARN"

          # AppSpec íŒŒì¼ì—ì„œ <TASK_DEFINITION> í”Œë ˆì´ìŠ¤í™€ë”ë¥¼ ì‹¤ì œ ARNìœ¼ë¡œ êµì²´
          sed "s|<TASK_DEFINITION>|$TASK_DEF_ARN|g" appspec.yml > deployment-appspec.yml

          echo "âœ… AppSpec prepared with Task Definition ARN"

      - name: Deploy with CodeDeploy
        id: deploy
        run: |
          echo "ğŸš€ Starting CodeDeploy deployment..."

          # CodeDeployìš© ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± (ìˆ˜ì •ëœ AppSpec ì‚¬ìš©)
          DEPLOYMENT_ARCHIVE="groble-prod-$(date +%Y%m%d-%H%M%S).zip"
          cp deployment-appspec.yml appspec.yml
          zip -r $DEPLOYMENT_ARCHIVE appspec.yml

          # S3 ë²„í‚· ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
          S3_BUCKET=$(aws s3api list-buckets \
            --query 'Buckets[?contains(Name, `groble-codedeploy-artifacts`)].Name' \
            --output text | head -1)

          if [ -z "$S3_BUCKET" ]; then
            echo "âŒ CodeDeploy S3 bucket not found!"
            exit 1
          fi

          # S3ì— ë°°í¬ ì•„í‹°íŒ©íŠ¸ ì—…ë¡œë“œ
          aws s3 cp $DEPLOYMENT_ARCHIVE s3://$S3_BUCKET/

          echo "ğŸ“¦ Deployment package uploaded: $DEPLOYMENT_ARCHIVE"

          # CodeDeploy ë°°í¬ ì‹œì‘
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name $CODEDEPLOY_APPLICATION \
            --deployment-group-name $CODEDEPLOY_DEPLOYMENT_GROUP \
            --s3-location bucket=$S3_BUCKET,key=$DEPLOYMENT_ARCHIVE,bundleType=zip \
            --description "Production deployment - ${{ steps.deploy-info.outputs.image-tag }}" \
            --query deploymentId \
            --output text)

          echo "deployment-id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT
          echo "ğŸ¯ CodeDeploy deployment started: $DEPLOYMENT_ID"

      - name: Wait for deployment completion
        run: |
          DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment-id }}"
          echo "â³ Waiting for deployment $DEPLOYMENT_ID to complete..."

          # CodeDeploy ë°°í¬ ì™„ë£Œ ëŒ€ê¸° (ìµœëŒ€ 30ë¶„)
          aws deploy wait deployment-successful \
            --deployment-id $DEPLOYMENT_ID \
            --cli-read-timeout 1800 \
            --cli-connect-timeout 60

          # ë°°í¬ ìƒíƒœ í™•ì¸
          DEPLOYMENT_STATUS=$(aws deploy get-deployment \
            --deployment-id $DEPLOYMENT_ID \
            --query 'deploymentInfo.status' \
            --output text)

          echo "âœ… Deployment completed with status: $DEPLOYMENT_STATUS"

      - name: Verify deployment
        run: |
          echo "ğŸ” Verifying deployment..."
          
          # ECS ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
          SERVICE_INFO=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount}')
          
          echo "ğŸ“Š ECS Service Status: $SERVICE_INFO"
          
          # ìš´ì˜ API ë„ë©”ì¸ìœ¼ë¡œ í—¬ìŠ¤ì²´í¬
          echo "ğŸ” Testing application health on apitest.groble.im..."
          
          # í—¬ìŠ¤ì²´í¬ (ìµœëŒ€ 5ë¶„ ëŒ€ê¸°) - ì˜¬ë°”ë¥¸ ë„ë©”ì¸ê³¼ ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©
          for i in {1..10}; do
            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://apitest.groble.im/actuator/health" || echo "000")
          
            if [ "$HTTP_STATUS" = "200" ]; then
              echo "âœ… Application is healthy! (HTTP $HTTP_STATUS)"
              # ì‘ë‹µ ë‚´ìš©ë„ í™•ì¸
              curl -s "https://apitest.groble.im/actuator/health" | jq '.' || echo "Response received but not JSON"
              break
            elif [ $i -eq 10 ]; then
              echo "âŒ Application health check failed after 5 minutes"
              echo "ğŸ” Last HTTP Status: $HTTP_STATUS"
              echo "ğŸ” Debug: Checking endpoint availability..."
              curl -v "https://apitest.groble.im/actuator/health" || true
              exit 1
            else
              echo "â³ Waiting for application to be ready... ($i/10) [HTTP: $HTTP_STATUS]"
              sleep 30
            fi
          done

#      - name: Notify deployment status
#        if: always()
#        uses: 8398a7/action-slack@v3
#        with:
#          status: ${{ job.status }}
#          text: |
#            ğŸš€ Production Deployment ${{ job.status }}!
#            Image: ${{ steps.deploy-info.outputs.image-tag }}
#            Commit: ${{ steps.deploy-info.outputs.commit-sha }}
#            Actor: ${{ steps.deploy-info.outputs.actor }}
#            Deployment ID: ${{ steps.deploy.outputs.deployment-id }}
#        env:
#          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}